package arweave

import (
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/sha512"
	"errors"
	"fmt"
	"math/big"
)

type Transaction struct {
	Format    int          `json:"format"`
	ID        string       `json:"id"`
	LastTx    Base64String `json:"last_tx"`
	Owner     Base64String `json:"owner"` // utils.Base64Encode(wallet.PubKey.N.Bytes())
	Tags      []Tag        `json:"tags"`
	Target    Base64String `json:"target"`
	Quantity  string       `json:"quantity"`
	Data      string       `json:"data"` // base64.encode
	DataSize  string       `json:"data_size"`
	DataRoot  Base64String `json:"data_root"`
	Reward    string       `json:"reward"`
	Signature Base64String `json:"signature"`

	// Computed when needed.
	Chunks *Chunks `json:"-"`
}

type Tag struct {
	Name  Base64String `json:"name" avro:"name"`
	Value Base64String `json:"value" avro:"value"`
}

// https://docs.arweave.org/developers/server/http-api#transaction-signing
// Transaction signatures are generated by computing a merkle root of the SHA-384 hashes of transaction fields:
// format, owner, target, data_root, data_size, quantity, reward, last_tx, tags, then signing the hash.
// Signatures are RSA-PSS with SHA-256 as the hashing function.
func (self *Transaction) Verify() (err error) {
	if self.Format != 2 {
		err = errors.New("unsupported transaction format version")
		return
	}

	tags := make([]interface{}, 0, len(self.Tags))
	for _, tag := range self.Tags {
		tags = append(tags, []interface{}{
			[]byte(tag.Name), []byte(tag.Value),
		})
	}

	// Initialize leaves of the merkle tree
	values := []interface{}{
		[]byte(fmt.Sprintf("%d", self.Format)),
		[]byte(self.Owner),
		[]byte(self.Target),
		[]byte(self.Quantity),
		[]byte(self.Reward),
		[]byte(self.LastTx),
		tags,
		[]byte(self.DataSize),
		[]byte(self.DataRoot),
	}

	ownerPublicKey := &rsa.PublicKey{
		N: new(big.Int).SetBytes([]byte(self.Owner)),
		E: 65537, //"AQAB"
	}

	deepHash := deepHash(values)
	hash := sha256.Sum256(deepHash[:])

	return rsa.VerifyPSS(ownerPublicKey, crypto.SHA256, hash[:], []byte(self.Signature), &rsa.PSSOptions{
		SaltLength: rsa.PSSSaltLengthAuto,
		Hash:       crypto.SHA256,
	})
}

func deepHash(data []any) [48]byte {
	tag := append([]byte("list"), []byte(fmt.Sprintf("%d", len(data)))...)
	tagHash := sha512.Sum384(tag)
	return deepHashAcc(data, tagHash)
}

func deepHashBytes(x []byte) [48]byte {
	tag := append([]byte("blob"), []byte(fmt.Sprintf("%d", len(x)))...)
	tagHash := sha512.Sum384(tag)
	blobHash := sha512.Sum384(x)
	tagged := append(tagHash[:], blobHash[:]...)
	return sha512.Sum384(tagged)
}

func convertToSliceOfAny[T string | []byte | Base64String](in []T) (out []any) {
	out = make([]any, len(in))
	for i, v := range in {
		out[i] = []byte(v)
	}
	return
}

func deepHashAcc(data []interface{}, acc [48]byte) [48]byte {
	if len(data) < 1 {
		return acc
	}

	dHash := [48]byte{}
	d := data[0]

	switch x := d.(type) {
	case []byte:
		dHash = deepHashBytes(x)
	case string:
		dHash = deepHashBytes([]byte(x))
	case Base64String:
		dHash = deepHashBytes([]byte(x))
	case RewardAddr:
		dHash = deepHashBytes([]byte(x))
	case []Base64String:
		dHash = deepHash(convertToSliceOfAny(x))
	case []string:
		dHash = deepHash(convertToSliceOfAny(x))
	case [][]byte:
		dHash = deepHash(convertToSliceOfAny(x))
	case []interface{}:
		dHash = deepHash(x)
	default:
		panic("unsupported deep hash type")
	}

	hashPair := append(acc[:], dHash[:]...)
	newAcc := sha512.Sum384(hashPair)
	return deepHashAcc(data[1:], newAcc)
}
