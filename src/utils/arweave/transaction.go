package arweave

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"encoding/json"
	"errors"
	"fmt"
	"math/big"
)

type Transaction struct {
	Format    int          `json:"format"`
	ID        Base64String `json:"id"`
	LastTx    Base64String `json:"last_tx"`
	Owner     Base64String `json:"owner"` // utils.Base64Encode(wallet.PubKey.N.Bytes())
	Tags      []Tag        `json:"tags"`
	Target    Base64String `json:"target"`
	Quantity  string       `json:"quantity"`
	Data      Base64String `json:"data"`
	DataSize  BigInt       `json:"data_size"`
	DataRoot  Base64String `json:"data_root"`
	Reward    string       `json:"reward"`
	Signature Base64String `json:"signature"`

	// Computed when needed.
	Chunks *Chunks `json:"-"`
}

type Tag struct {
	Name  Base64String `json:"name"`
	Value Base64String `json:"value"`
}

func (tx *Transaction) GetTag(name string) (value string, ok bool) {
	for _, tag := range tx.Tags {
		if string(tag.Name) == name {
			return string(tag.Value), true
		}
	}
	return
}

// https://docs.arweave.org/developers/server/http-api#transaction-signing
// Transaction signatures are generated by computing a merkle root of the SHA-384 hashes of transaction fields:
// format, owner, target, data_root, data_size, quantity, reward, last_tx, tags, then signing the hash.
// Signatures are RSA-PSS with SHA-256 as the hashing function.
func (tx *Transaction) Verify() (err error) {
	if tx.Format != 2 {
		err = errors.New("unsupported transaction format version")
		return
	}

	// Check if id is the hash of the signature
	sigHash := sha256.Sum256(tx.Signature)
	if !bytes.Equal(tx.ID, sigHash[:]) {
		err = errors.New("id and signature don't match")
		return
	}

	// Convert tags for deep hashing
	tags := make([]interface{}, 0, len(tx.Tags))
	for _, tag := range tx.Tags {
		tags = append(tags, []interface{}{
			[]byte(tag.Name), []byte(tag.Value),
		})
	}

	// Initialize leaves of the merkle tree
	values := []interface{}{
		fmt.Sprintf("%d", tx.Format),
		tx.Owner,
		tx.Target,
		tx.Quantity,
		tx.Reward,
		tx.LastTx,
		tags,
		tx.DataSize,
		tx.DataRoot,
	}

	ownerPublicKey := &rsa.PublicKey{
		N: new(big.Int).SetBytes([]byte(tx.Owner)),
		E: 65537, //"AQAB"
	}

	deepHash := DeepHash(values)
	hash := sha256.Sum256(deepHash[:])

	return rsa.VerifyPSS(ownerPublicKey, crypto.SHA256, hash[:], []byte(tx.Signature), &rsa.PSSOptions{
		SaltLength: rsa.PSSSaltLengthAuto,
		Hash:       crypto.SHA256,
	})
}

func (tx Transaction) MarshalJSON() ([]byte, error) {
	type TransactionAlias Transaction
	return json.Marshal(&struct {
		*TransactionAlias
	}{TransactionAlias: (*TransactionAlias)(&tx)})
}

func (tx *Transaction) UnmarshalJSON(data []byte) error {
	type TransactionAlias Transaction
	aux := &struct {
		*TransactionAlias
	}{TransactionAlias: (*TransactionAlias)(tx)}

	return json.Unmarshal(data, aux)
}

func (tx Transaction) MarshalTo(buf []byte) (int, error) {
	json, err := tx.MarshalJSON()
	if err != nil {
		return 0, err
	}
	copy(buf, json)
	return len(json), nil
}

func (tx *Transaction) Unmarshal(data []byte) error {
	return tx.UnmarshalJSON(data)
}

func (tx *Transaction) Size() int {
	json, err := tx.MarshalJSON()
	if err != nil {
		panic(err)
	}
	return len(json)
}
